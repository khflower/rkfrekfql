<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>개인용 Gemini 채팅</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 사용자 정의 스타일 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 스크롤바 스타일 */
        #chat-output::-webkit-scrollbar { width: 8px; }
        #chat-output::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #chat-output::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #chat-output::-webkit-scrollbar-thumb:hover { background: #555; }

        .message-container { display: flex; flex-direction: column; margin-bottom: 0.5rem; }
        .message-container.user { align-items: flex-end; }
        .message-container.model { align-items: flex-start; }

        .message {
            max-width: 90%; word-wrap: break-word; position: relative;
            padding: 0.75rem; border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .user-message { background-color: #d1eaff; }
        .model-message { background-color: #e2e8f0; }

        /* 메시지 액션 버튼 (수정/삭제) */
        .message-actions {
            position: absolute; top: 2px; right: 4px; display: none;
            background-color: rgba(255, 255, 255, 0.8); border-radius: 4px;
            padding: 1px 3px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .message-container:hover .message-actions { display: flex; gap: 4px; }
        .message-actions button { background: none; border: none; cursor: pointer; padding: 2px; line-height: 1; }
        .message-actions button svg { width: 14px; height: 14px; color: #555; }
        .message-actions button:hover svg { color: #000; }

         /* 수정 모드 스타일 */
         .edit-textarea {
             width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
             font-size: inherit; min-height: 60px; resize: vertical; margin-bottom: 4px;
         }
         .edit-actions button { padding: 4px 8px; font-size: 12px; border-radius: 4px; cursor: pointer; }
         .edit-actions .save-btn { background-color: #4CAF50; color: white; }
         .edit-actions .cancel-btn { background-color: #f44336; color: white; margin-left: 4px;}

        /* 로딩 스피너 */
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 24px; height: 24px;
            animation: spin 1s linear infinite; margin: 10px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* 이미지 미리보기 */
        #image-preview img {
            max-width: 100px; max-height: 100px; margin-top: 5px;
            border-radius: 8px; border: 1px solid #ccc;
        }

        /* 모바일 설정 오버레이 스타일 */
        #settings-overlay {
             transition: opacity 0.3s ease-in-out;
        }
        #settings-sidebar {
            transition: transform 0.3s ease-in-out;
            /* 모바일에서 오른쪽에서 슬라이드 인 효과 (선택 사항) */
            /* transform: translateX(100%); */
        }
        /* body 스크롤 방지 클래스 */
        .overflow-hidden-body {
             overflow: hidden;
        }

        /* 모바일 사이드바 열렸을 때 (transform 예시) */
        /* #settings-sidebar.open {
             transform: translateX(0);
        } */

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <header class="bg-blue-600 text-white p-4 shadow-md flex justify-between items-center">
        <button id="mobile-settings-btn" class="md:hidden p-2 rounded-md hover:bg-blue-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
        </button>

        <h1 class="text-xl sm:text-2xl font-bold text-center flex-grow md:flex-grow-0">Gemini 2.5 Pro 채팅</h1>

        <div class="hidden md:flex items-center space-x-2">
             <button id="new-chat-btn" class="px-3 py-1 bg-gray-500 text-white rounded-md hover:bg-gray-600 text-sm">새 대화</button>
             <button id="save-chat-btn" class="px-3 py-1 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm">대화 저장</button>
             <button id="load-chat-btn" class="px-3 py-1 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 text-sm">대화 불러오기</button>
             <input type="file" id="load-chat-input" accept=".json" class="hidden">
        </div>
         <div class="md:hidden w-8 h-8"></div> </header>

    <div class="flex flex-1 overflow-hidden">

        <aside id="settings-sidebar" class="w-full md:w-1/4 h-full md:h-auto bg-white p-4 shadow-lg flex flex-col
                     fixed top-0 left-0 z-40 overflow-y-auto  hidden  md:static md:flex md:shadow md:translate-x-0 md:z-auto md:overflow-y-visible ">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                 <h2 class="text-lg font-semibold">설정</h2>
                 <button id="close-sidebar-btn" class="md:hidden p-1">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                         <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                     </svg>
                 </button>
            </div>

            <div class="flex-grow overflow-y-auto md:overflow-y-visible">
                <div class="mb-3">
                    <label for="api-key-input" class="block text-sm font-medium text-gray-700 mb-1">새 API 키 추가:</label>
                    <div class="flex space-x-2">
                        <input type="password" id="api-key-input" class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm" placeholder="Google API 키 입력">
                        <button id="add-key-btn" class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 text-sm">추가</button>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="api-key-select" class="block text-sm font-medium text-gray-700 mb-1">사용할 API 키 선택:</label>
                    <select id="api-key-select" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 mb-2 text-sm">
                        <option value="">-- 키를 선택하세요 --</option>
                    </select>
                     <button id="remove-key-btn" class="w-full px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 text-sm">선택한 키 삭제</button>
                </div>
                 <p class="text-xs text-gray-500 mb-3">API 키는 브라우저 저장소(localStorage)에만 저장됩니다.</p>
                 <div class="mb-3">
                    <label for="system-prompt-input" class="block text-sm font-medium text-gray-700 mb-1">시스템 프롬프트:</label>
                    <textarea id="system-prompt-input" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm" rows="4" placeholder="모델에게 전달할 시스템 메시지를 입력하세요 (선택 사항)"></textarea>
                </div>
            </div>

             <div class="mt-auto space-y-2 pt-3 border-t md:hidden">
                 <button id="new-chat-btn-mobile" class="w-full px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 text-sm">새 대화</button>
                 <button id="save-chat-btn-mobile" class="w-full px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm">대화 저장</button>
                 <button id="load-chat-btn-mobile" class="w-full px-3 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 text-sm">대화 불러오기</button>
            </div>
        </aside>

        <div id="settings-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden md:hidden"></div>

        <main class="flex-1 flex flex-col bg-white rounded-lg shadow overflow-hidden md:ml-0"> <div id="chat-output" class="flex-1 p-4 overflow-y-auto space-y-0 flex flex-col bg-gray-50"> </div>
            <div id="loading-indicator" class="hidden p-4 text-center">
                <div class="loader"></div>
                <p class="text-sm text-gray-500">응답을 기다리는 중...</p>
            </div>
            <div class="p-2 sm:p-4 border-t border-gray-200 bg-white">
                 <div id="image-preview-container" class="mb-2 flex items-center space-x-2 hidden">
                    <div id="image-preview"></div>
                    <button id="remove-image-btn" class="text-red-500 hover:text-red-700 text-sm font-medium">이미지 제거</button>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="message-input" class="flex-grow p-2 border border-gray-300 rounded-md resize-none focus:ring-blue-500 focus:border-blue-500 text-sm sm:text-base" rows="2" placeholder="메시지를 입력하세요..."></textarea>
                    <label for="image-upload" class="cursor-pointer p-2 bg-gray-200 rounded-md hover:bg-gray-300" title="이미지 업로드">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 sm:h-6 sm:w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                        <input type="file" id="image-upload" accept="image/*" class="hidden">
                    </label>
                    <button id="send-button" class="px-3 py-2 sm:px-4 sm:py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base">전송</button>
                </div>
                 <div class="mt-2 text-right text-xs text-gray-500">
                    예상 토큰: <span id="token-count-display">N/A</span>
                 </div>
            </div>
        </main>
    </div>

    <script>
        // --- 요소 가져오기 ---
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyBtn = document.getElementById('add-key-btn');
        const apiKeySelect = document.getElementById('api-key-select');
        const removeKeyBtn = document.getElementById('remove-key-btn');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const chatOutput = document.getElementById('chat-output');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const imageUpload = document.getElementById('image-upload');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const removeImageBtn = document.getElementById('remove-image-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const newChatBtn = document.getElementById('new-chat-btn'); // 데스크탑 버튼
        const saveChatBtn = document.getElementById('save-chat-btn'); // 데스크탑 버튼
        const loadChatBtn = document.getElementById('load-chat-btn'); // 데스크탑 버튼
        const loadChatInput = document.getElementById('load-chat-input');
        const newChatBtnMobile = document.getElementById('new-chat-btn-mobile'); // 모바일 버튼
        const saveChatBtnMobile = document.getElementById('save-chat-btn-mobile'); // 모바일 버튼
        const loadChatBtnMobile = document.getElementById('load-chat-btn-mobile'); // 모바일 버튼
        const tokenCountDisplay = document.getElementById('token-count-display');
        // 모바일 설정 관련 요소 추가
        const mobileSettingsBtn = document.getElementById('mobile-settings-btn');
        const settingsSidebar = document.getElementById('settings-sidebar');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const settingsOverlay = document.getElementById('settings-overlay');


        // --- 상태 변수 ---
        let apiKeys = [];
        let chatHistory = [];
        let selectedImageBase64 = null;
        let selectedImageMimeType = null;
        let isLoading = false;
        let messageCounter = 0;
        let debounceTimer;

        // --- 상수 ---
        const TARGET_MODEL_NAME = "gemini-2.5-pro-exp-03-25";
        const API_URL_BASE = `https://generativelanguage.googleapis.com/v1beta/models/${TARGET_MODEL_NAME}:generateContent?key=`;
        const COUNT_TOKENS_URL_BASE = `https://generativelanguage.googleapis.com/v1beta/models/${TARGET_MODEL_NAME}:countTokens?key=`;
        const LOCAL_STORAGE_KEY = 'gemini_api_keys';
        const LOCAL_STORAGE_PROMPT_KEY = 'gemini_system_prompt';
        const DEBOUNCE_DELAY = 500;

        // --- 아이콘 SVG ---
        const editIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487Zm0 0L19.5 7.125" /></svg>`;
        const deleteIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>`;


        // --- 유틸리티 함수 ---
        function debounce(func, delay) { /* 이전과 동일 */
            return function(...args) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => { func.apply(this, args); }, delay);
            };
        }

        // --- 함수 ---
        // (loadApiKeys, saveApiKeys, loadSystemPrompt, saveSystemPrompt, updateApiKeySelect, addApiKey, removeApiKey 함수는 이전과 동일)
        function loadApiKeys() { const storedKeys = localStorage.getItem(LOCAL_STORAGE_KEY); if (storedKeys) apiKeys = JSON.parse(storedKeys); updateApiKeySelect(); }
        function saveApiKeys() { localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(apiKeys)); }
        function loadSystemPrompt() { const storedPrompt = localStorage.getItem(LOCAL_STORAGE_PROMPT_KEY); if (storedPrompt) systemPromptInput.value = storedPrompt; }
        function saveSystemPrompt() { localStorage.setItem(LOCAL_STORAGE_PROMPT_KEY, systemPromptInput.value); }
        function updateApiKeySelect() { const selectedValue = apiKeySelect.value; apiKeySelect.innerHTML = '<option value="">-- 키를 선택하세요 --</option>'; apiKeys.forEach((key, index) => { const displayKey = key.length > 8 ? `${key.substring(0, 4)}...${key.substring(key.length - 4)}` : key; const option = document.createElement('option'); option.value = key; option.textContent = `키 ${index + 1} (${displayKey})`; apiKeySelect.appendChild(option); }); if (apiKeys.includes(selectedValue)) apiKeySelect.value = selectedValue; removeKeyBtn.disabled = apiKeys.length === 0 || !apiKeySelect.value; debouncedUpdateTokenCount(); }
        function addApiKey() { const newKey = apiKeyInput.value.trim(); if (newKey && !apiKeys.includes(newKey)) { apiKeys.push(newKey); saveApiKeys(); updateApiKeySelect(); apiKeyInput.value = ''; alert('API 키가 추가되었습니다.'); } else if (apiKeys.includes(newKey)) { alert('이미 존재하는 API 키입니다.'); } else { alert('유효한 API 키를 입력하세요.'); } }
        function removeApiKey() { const selectedKey = apiKeySelect.value; if (selectedKey) { if (confirm('선택한 API 키를 삭제하시겠습니까?')) { apiKeys = apiKeys.filter(key => key !== selectedKey); saveApiKeys(); updateApiKeySelect(); alert('API 키가 삭제되었습니다.'); } } else { alert('삭제할 API 키를 선택하세요.'); } }

        function displayMessage(sender, parts, messageId, addToHistory = true) { /* 이전과 동일 */
            const messageParts = Array.isArray(parts) ? parts : [{ text: parts }];
            const messageContainer = document.createElement('div');
            messageContainer.classList.add('message-container', sender === 'user' ? 'user' : 'model');
            messageContainer.dataset.messageId = messageId;
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', sender === 'user' ? 'user-message' : 'model-message');
            messageElement.id = `message-body-${messageId}`;
            let messageContentHtml = '';
            let isEditable = true;
            messageParts.forEach(part => {
                if (part.text) { messageContentHtml += part.text.replace(/\n/g, '<br>'); }
                else if (part.inline_data) { isEditable = false; messageContentHtml += `<br><img src="data:${part.inline_data.mime_type};base64,${part.inline_data.data}" alt="첨부 이미지" style="max-width: 150px; max-height: 150px; margin-top: 5px; border-radius: 5px;">`; }
                else { isEditable = false; }
            });
            messageElement.innerHTML = messageContentHtml;
            const actionsContainer = document.createElement('div');
            actionsContainer.classList.add('message-actions');
            if (isEditable) { const editButton = document.createElement('button'); editButton.title = '수정'; editButton.innerHTML = editIconSVG; editButton.onclick = () => startEditMessage(messageId); actionsContainer.appendChild(editButton); }
            const deleteButton = document.createElement('button'); deleteButton.title = '삭제'; deleteButton.innerHTML = deleteIconSVG; deleteButton.onclick = () => deleteMessage(messageId); actionsContainer.appendChild(deleteButton);
            messageElement.appendChild(actionsContainer);
            messageContainer.appendChild(messageElement);
            chatOutput.appendChild(messageContainer);
            chatOutput.scrollTop = chatOutput.scrollHeight;
            if (addToHistory) { const role = (sender === 'user') ? 'user' : 'model'; chatHistory.push({ id: messageId, role: role, parts: messageParts }); }
        }
        function deleteMessage(messageId) { /* 이전과 동일 */
            if (confirm('메시지를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                const messageContainer = chatOutput.querySelector(`.message-container[data-message-id="${messageId}"]`);
                if (messageContainer) messageContainer.remove();
                const indexToDelete = chatHistory.findIndex(msg => msg.id === messageId);
                if (indexToDelete > -1) { chatHistory.splice(indexToDelete, 1); console.log("Chat history after deletion:", chatHistory); debouncedUpdateTokenCount(); }
            }
        }
        function startEditMessage(messageId) { /* 이전과 동일 */
            const messageBodyElement = document.getElementById(`message-body-${messageId}`); if (!messageBodyElement) return;
            const existingEditArea = chatOutput.querySelector('.edit-textarea'); if (existingEditArea) { const editingId = existingEditArea.closest('.message-container').dataset.messageId; cancelMessageEdit(editingId); }
            const messageData = chatHistory.find(msg => msg.id === messageId); const originalText = messageData.parts.reduce((acc, part) => acc + (part.text || ''), '');
            messageBodyElement.style.display = 'none';
            const editContainer = document.createElement('div'); editContainer.id = `edit-container-${messageId}`;
            const textarea = document.createElement('textarea'); textarea.classList.add('edit-textarea'); textarea.value = originalText;
            const editActions = document.createElement('div'); editActions.classList.add('edit-actions');
            const saveBtn = document.createElement('button'); saveBtn.textContent = '저장'; saveBtn.classList.add('save-btn'); saveBtn.onclick = () => saveMessageEdit(messageId);
            const cancelBtn = document.createElement('button'); cancelBtn.textContent = '취소'; cancelBtn.classList.add('cancel-btn'); cancelBtn.onclick = () => cancelMessageEdit(messageId);
            editActions.appendChild(saveBtn); editActions.appendChild(cancelBtn); editContainer.appendChild(textarea); editContainer.appendChild(editActions);
            messageBodyElement.parentNode.appendChild(editContainer); textarea.focus();
        }
        function saveMessageEdit(messageId) { /* 이전과 동일 */
            const editContainer = document.getElementById(`edit-container-${messageId}`); const textarea = editContainer.querySelector('.edit-textarea'); const newText = textarea.value;
            const messageIndex = chatHistory.findIndex(msg => msg.id === messageId); if (messageIndex > -1) { chatHistory[messageIndex].parts = [{ text: newText }]; console.log("Chat history after edit:", chatHistory); debouncedUpdateTokenCount(); }
            const messageBodyElement = document.getElementById(`message-body-${messageId}`); messageBodyElement.innerHTML = newText.replace(/\n/g, '<br>');
            const actionsContainer = document.createElement('div'); actionsContainer.classList.add('message-actions');
            const editButton = document.createElement('button'); editButton.title = '수정'; editButton.innerHTML = editIconSVG; editButton.onclick = () => startEditMessage(messageId); actionsContainer.appendChild(editButton);
            const deleteButton = document.createElement('button'); deleteButton.title = '삭제'; deleteButton.innerHTML = deleteIconSVG; deleteButton.onclick = () => deleteMessage(messageId); actionsContainer.appendChild(deleteButton);
            messageBodyElement.appendChild(actionsContainer); editContainer.remove(); messageBodyElement.style.display = '';
        }
        function cancelMessageEdit(messageId) { /* 이전과 동일 */
            const editContainer = document.getElementById(`edit-container-${messageId}`); if (editContainer) editContainer.remove();
            const messageBodyElement = document.getElementById(`message-body-${messageId}`); if (messageBodyElement) messageBodyElement.style.display = '';
        }
        function handleImageUpload(event) { /* 이전과 동일 */
            const file = event.target.files[0]; if (file) { if (file.size > 5 * 1024 * 1024) { alert('이미지 파일 크기는 5MB를 초과할 수 없습니다.'); imageUpload.value = ''; return; } const reader = new FileReader(); reader.onloadend = function() { selectedImageBase64 = reader.result.split(',')[1]; selectedImageMimeType = file.type; imagePreview.innerHTML = `<img src="${reader.result}" alt="선택된 이미지">`; imagePreviewContainer.classList.remove('hidden'); removeImageBtn.disabled = false; debouncedUpdateTokenCount(); } reader.readAsDataURL(file); }
        }
        function removeImage() { /* 이전과 동일 */
            selectedImageBase64 = null; selectedImageMimeType = null; imageUpload.value = ''; imagePreview.innerHTML = ''; imagePreviewContainer.classList.add('hidden'); removeImageBtn.disabled = true; debouncedUpdateTokenCount();
        }
        function setLoading(loading) { /* 이전과 동일 */
            isLoading = loading; loadingIndicator.style.display = loading ? 'block' : 'none'; sendButton.disabled = loading; messageInput.disabled = loading; imageUpload.disabled = loading; removeImageBtn.disabled = loading || selectedImageBase64 === null;
        }
        async function sendMessage() { /* 이전과 동일 */
            const messageText = messageInput.value.trim(); const selectedApiKey = apiKeySelect.value; const systemPrompt = systemPromptInput.value.trim();
            if (!selectedApiKey) { alert('사용할 API 키를 선택하세요.'); return; } if (!messageText && !selectedImageBase64) { alert('메시지를 입력하거나 이미지를 첨부하세요.'); return; } if (isLoading) return;
            setLoading(true);
            const userParts = []; if (messageText) userParts.push({ text: messageText }); if (selectedImageBase64 && selectedImageMimeType) { userParts.push({ inline_data: { mime_type: selectedImageMimeType, data: selectedImageBase64 } }); }
            const userMessageId = `msg-${Date.now()}-${messageCounter++}`; displayMessage('user', userParts, userMessageId, true);
            const requestBody = { contents: chatHistory.map(({ role, parts }) => ({ role, parts })) }; if (systemPrompt) { requestBody.system_instruction = { parts: [{ text: systemPrompt }] }; }
            messageInput.value = ''; removeImage(); debouncedUpdateTokenCount();
            try {
                const response = await fetch(API_URL_BASE + selectedApiKey, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody), });
                if (!response.ok) { let errorData; try { errorData = await response.json(); } catch (e) {} const errorMessage = errorData?.error?.message || `API 요청 실패: ${response.status}`; throw new Error(errorMessage); }
                const data = await response.json(); let modelResponseParts = [{ text: "응답을 받지 못했습니다." }]; if (data.candidates?.[0]?.content?.parts) { modelResponseParts = data.candidates[0].content.parts; } else { console.error("Unexpected API response structure:", data); modelResponseParts = [{ text: "예상치 못한 응답 형식입니다. 콘솔을 확인하세요." }]; }
                const modelMessageId = `msg-${Date.now()}-${messageCounter++}`; displayMessage('model', modelResponseParts, modelMessageId, true); debouncedUpdateTokenCount();
            } catch (error) { console.error('API 호출 오류:', error); const errorMessageId = `msg-${Date.now()}-${messageCounter++}`; displayMessage('model', [{ text: `오류 발생: ${error.message}` }], errorMessageId, true); debouncedUpdateTokenCount(); } finally { setLoading(false); }
        }
        function saveChatHistory() { /* 이전과 동일 */
            if (chatHistory.length === 0) { alert('저장할 대화 내용이 없습니다.'); return; } const dataToSave = { systemPrompt: systemPromptInput.value, history: chatHistory }; const jsonString = JSON.stringify(dataToSave, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); a.download = `gemini_chat_${timestamp}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }
        function triggerLoadChat() { /* 이전과 동일 */
            loadChatInput.click();
        }
        function handleChatLoad(event) { /* 이전과 동일 */
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const loadedData = JSON.parse(e.target.result); if (!loadedData || !Array.isArray(loadedData.history)) { throw new Error('잘못된 파일 형식입니다. history 배열이 필요합니다.'); } systemPromptInput.value = loadedData.systemPrompt || ''; saveSystemPrompt(); chatOutput.innerHTML = ''; chatHistory = loadedData.history.map((item, index) => ({ ...item, id: item.id || `msg-loaded-${Date.now()}-${index}` })); messageCounter = chatHistory.length; chatHistory.forEach(item => { displayMessage(item.role === 'user' ? 'user' : 'model', item.parts, item.id, false); }); alert('대화 내역을 불러왔습니다.'); debouncedUpdateTokenCount(); } catch (error) { console.error('대화 불러오기 오류:', error); alert(`대화 내역을 불러오는 중 오류가 발생했습니다: ${error.message}`); } finally { loadChatInput.value = ''; } }; reader.onerror = function() { alert('파일을 읽는 중 오류가 발생했습니다.'); loadChatInput.value = ''; }; reader.readAsText(file);
        }
        function displayInitialMessage() { /* 이전과 동일 */
             const initialMsgId = `msg-initial-${Date.now()}`; displayMessage('model', '안녕하세요! 사용할 API 키를 선택하고 메시지를 입력하세요. 이미지 파일 첨부도 가능합니다.', initialMsgId, false);
        }
        function startNewChat() { /* 이전과 동일 */
            if (confirm('새 대화를 시작하시겠습니까? 현재 대화 내용이 초기화됩니다.')) { chatHistory = []; messageCounter = 0; chatOutput.innerHTML = ''; removeImage(); displayInitialMessage(); alert('새 대화를 시작합니다.'); debouncedUpdateTokenCount(); }
        }
        async function updateTokenCount() { /* 이전과 동일 */
            const selectedApiKey = apiKeySelect.value; if (!selectedApiKey) { tokenCountDisplay.textContent = 'N/A'; return; }
            const currentInputText = messageInput.value.trim(); const currentParts = []; if (currentInputText) { currentParts.push({ text: currentInputText }); } if (selectedImageBase64 && selectedImageMimeType) { currentParts.push({ inline_data: { mime_type: selectedImageMimeType, data: selectedImageBase64 } }); }
            const contentsForCount = chatHistory.map(({ role, parts }) => ({ role, parts })); if (currentParts.length > 0) { contentsForCount.push({ role: 'user', parts: currentParts }); }
            const systemPrompt = systemPromptInput.value.trim(); const requestBodyForCount = { contents: contentsForCount }; if (systemPrompt) { requestBodyForCount.system_instruction = { parts: [{ text: systemPrompt }] }; }
            if (contentsForCount.length === 0 && !systemPrompt) { tokenCountDisplay.textContent = '0'; return; }
            tokenCountDisplay.textContent = '계산 중...';
            try {
                const response = await fetch(COUNT_TOKENS_URL_BASE + selectedApiKey, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBodyForCount), });
                if (!response.ok) { console.error('Token count API error:', response.status, response.statusText); let errorData; try { errorData = await response.json(); console.error(errorData); } catch(e) {} tokenCountDisplay.textContent = '오류'; return; }
                const data = await response.json(); if (data.totalTokens !== undefined) { tokenCountDisplay.textContent = data.totalTokens; } else { tokenCountDisplay.textContent = 'N/A'; }
            } catch (error) { console.error('Failed to fetch token count:', error); tokenCountDisplay.textContent = '오류'; }
        }
        const debouncedUpdateTokenCount = debounce(updateTokenCount, DEBOUNCE_DELAY);

        // 모바일 설정 사이드바 토글 함수
        function toggleMobileSettings() {
            const isOpen = settingsSidebar.classList.toggle('hidden'); // hidden 클래스 토글
            settingsOverlay.classList.toggle('hidden'); // 오버레이 토글

            // 사이드바 열릴 때 body 스크롤 방지, 닫힐 때 해제
            if (!isOpen) { // hidden 클래스가 제거되었으면 열린 상태
                 document.body.classList.add('overflow-hidden-body');
            } else {
                 document.body.classList.remove('overflow-hidden-body');
            }
        }

        // --- 이벤트 리스너 ---
        // (기존 리스너들은 이전과 동일)
        addKeyBtn.addEventListener('click', addApiKey);
        removeKeyBtn.addEventListener('click', removeApiKey);
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('input', debouncedUpdateTokenCount);
        imageUpload.addEventListener('change', handleImageUpload);
        removeImageBtn.addEventListener('click', removeImage);
        apiKeySelect.addEventListener('change', updateApiKeySelect);
        systemPromptInput.addEventListener('input', debouncedUpdateTokenCount);
        // 데스크탑 버튼 리스너
        if (newChatBtn) newChatBtn.addEventListener('click', startNewChat);
        if (saveChatBtn) saveChatBtn.addEventListener('click', saveChatHistory);
        if (loadChatBtn) loadChatBtn.addEventListener('click', triggerLoadChat);
        // 모바일 버튼 리스너 (사이드바 안에 있음)
        if (newChatBtnMobile) newChatBtnMobile.addEventListener('click', startNewChat);
        if (saveChatBtnMobile) saveChatBtnMobile.addEventListener('click', saveChatHistory);
        if (loadChatBtnMobile) loadChatBtnMobile.addEventListener('click', triggerLoadChat);
        // 파일 로드 리스너
        if (loadChatInput) loadChatInput.addEventListener('change', handleChatLoad);

        // 모바일 설정 토글 리스너 추가
        if (mobileSettingsBtn) mobileSettingsBtn.addEventListener('click', toggleMobileSettings);
        if (closeSidebarBtn) closeSidebarBtn.addEventListener('click', toggleMobileSettings);
        if (settingsOverlay) settingsOverlay.addEventListener('click', toggleMobileSettings);


        // --- 초기화 ---
        loadApiKeys();
        loadSystemPrompt();
        displayInitialMessage();
        setLoading(false);
        removeImageBtn.disabled = true;
        if (apiKeySelect.value) { debouncedUpdateTokenCount(); }
        else { tokenCountDisplay.textContent = 'N/A'; }

    </script>

</body>
</html>
